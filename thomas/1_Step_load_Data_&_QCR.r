# install.packages("tidyr")
# install.packages("stringr")
# install.packages("patchwork")
# install.packages("ggplot2")

# install.packages("Seurat")

## SeuratDisk is not on CRAN, use remotes
# install.packages("remotes")
# remotes::install_github("mojaveazure/seurat-disk")

library(Seurat)
library(SeuratDisk)
library(tidyr)
library(stringr)
library(patchwork)
library(ggplot2)

#################
### Load file ###
#################

# # .h5 file
# obj <- read10X_h5(
# 	filename = "filename.h5",
# 	user.names = TRUE,
# 	unique.features = TRUE
# # )

# # .mtx file
# obj <- ReadMtx(
# 	mtx = "matrix.mtx.gz",
# 	cells = "barcodes.tsv.gz",
# 	features = "features.tsv.gz"
# )
# # or
# obj <- Read10X(data.dir = "/dir_file/")

# # .loom file
# obj <- as.Seurat(Connect(filename = "filename.loom", mode = "r"))

# # .rds file
# obj <- readRDS(file = "filename.rds")

# # .h5ad file
# Convert(
# 	source = "filename.h5ad",
# 	dest = "h5seurat",
# 	overwrite = TRUE
# )
# # load h5Seurat file
# obj <- LoadH5Seurat(file = "filename.h5seurat")

# # Initialize the seurat object
# seurat_obj <- CreateSeuratObject(counts = obj)


#################
### Load data ###
#################

# Unzip *.gz in terminal: gunzip *.gz
dir_path <- "data/GSE150728_RAW"

# list files in the folder
mat.list = paste(dir_path, list.files(pattern = "*.matrices.rds", path = dir_path), sep="/")

# load data into R and generate sparse matrices
mat.files <- lapply(mat.list, readRDS)

# assign a name to each matrix
names(mat.files) <- sapply(strsplit(sub("_cell.counts.matrices.rds", "", mat.list), "/"), function(x) tail(x, 1))

# -NOTE: The mat.files object contains three count matrices generated by
# the dropEsst pipeline tool: exon, intron, and exon/intron spanning reads.
# Since exonic reads are the reads used in scRNA-seq analysis for quantifying
# gene expression, we select only the exonic count for each sample.
# Exon -> DNA that exits the Nucleus, so the one that is translated into a protein

# Look at the counts of first 20 genes and cells for on sample
# exon is: genes x cells
mat.files$GSM4557329_556$exon[1:20, 1:20]


# initialize a seurat object for each sample by filtering out genes that are expressed in fewer than 10 cells
# (mild filtering)
# list of matrices
# keep only the exon
seurat.list <- lapply(mat.files, function(x) {
  CreateSeuratObject(
    counts = x$exon,
    names.field = 1,
    names.delim = "\\.",
    project = "CovidProject",
    min.cells = 10,
    min.features = 0
  )
})
print(seurat.list)


# seural list -> multi-levels layesr (addition to origin count matrix,  also store data fenerated during the analysis, normalized counts, clustering results)

# let's look at one suerat object
seurat.list$GSM4557329_556

# show nb of cells and genes 
ncol(seurat.list$GSM4557329_556) # nb cells
nrow(seurat.list$GSM4557329_556) # nb genes


# get cell/ barcode names
colnames(seurat.list$GSM4557329_556)
Cells(seurat.list$GSM4557329_556) # names of the cells

# get gene/ featurs names
rownames(seurat.list$GSM4557329_556)
Features(seurat.list$GSM4557329_556)


# get count matrix 
seurat.list$GSM4557329_556@assays$RNA$counts
seurat.list$GSM4557329_556[['RNA']]$counts


# seurat package offers practical functions to quickly access information 
# to get the count matrix
GetAssayData(object = seurat.list$GSM4557329_556, layer = "counts")


#######################
### Assign Metadata ###
#######################

# vizualise metadata 

View(seurat.list$GSM4557329_556@meta.data)
#ncount_RNA 
#nFeature_RNA (genes)

# Add new metadata 
# sample name
# condtition - label indicating sample condition / group
sample_names <- names(seurat.list)
for (i in seq_along(seurat.list)) {
    seurat.list[[i]]@meta.data$sample <- unlist(strsplit(sample_names[i], split = "_"))[1]
    seurat.list[[i]]@meta.data$condition <- ifelse(grepl("HIP", sample_names[i]), "hc", "covid") 
}

# vizualise metadata again
head(seurat.list$GSM4557329_556@meta.data)

################################# Data QC ################################

# Vizualize QC per cell 

# one sample 

# plot the number of read/UMI counts and detected genes per cell to evaluate
# their distribution and identify cells and genes that cause variation in the dataset
# due to technical reasons (e.g sampling or dissociation)

# cells with low counts or detected genes might be uninformative 
# while high counts or detected genes could indicate doublets

VlnPlot(seurat.list$GSM4557329_556, features = c("nCount_RNA", "nFeature_RNA"), group.by = "sample")
ggsave("thomas/images/counts_features_by_cell.png", width =  3500, height = 1500, dpi = 300, units = "px")

# Plot the correlation between the number of read counts and detected genes per cell to identify an upper threshold
# High quality cells show a higher number of reads and a higher number of detected genes (good correlation)

# Note: The FeatureScatter draws a scatter plot from a seurat object
FeatureScatter(seurat.list$GSM4557329_556,
               "nCount_RNA", "nFeature_RNA",
               group.by = "sample")
ggsave("thomas/images/counts_vs_features.png", width = 1500, height = 1000, dpi = 300, units = "px")

# --- All samples ---#

# Plot the number of read/UMI counts per cell for each sample
plots.list <- lapply(seurat.list, function(x) {
  VlnPlot(x, features = c("nCount_RNA"),
          group.by = "sample")
})
wrap_plots(plots.list, ncol = 3)
ggsave("thomas/images/features_by_cell_by_sample.png", width = 6000, height = 3000, dpi = 300, units = "px")







