library(Seurat)
library(SeuratDisk)
library(tidyr)
library(stringr)
library(patchwork)
library(ggplot2)
# library(readxl)
# genes x cells


# mtx file format

#obj <- Read10X_h5(filename = "filename.h5", use.names = TRUE, unique.features = TRUE)

#obj <- ReadMtx(mtx = "matrix.mtx.gz", cells = "barcodes.tsv.gz", features = "features.tsv.gz")

#obj <- Read10x(data.dir = "/dir_file/")

# obj = as.Seurat(Connect(filename =  "filename.loom", mode = 'r'))

#obj = readRDS(file = 'filename.rds")

# convert .h5ad file format to an h5Seurat file 
# Convert(source = 'filename.h5ad', dest = "h5seurat", overwrite = TRUE)

# load h5Seurat file 
# obj <- LoadH5Seurat(file = "filename.h5seurat")

# initizialize the seurat object
# seurat_obj <- CreateSeuratObject(counts = obj)





########### Download and Load scRNA-seq data ######################


# 3 patients and 3 healthy controls


# unzip files in terminal : gunzip *.gz

# path to the data folder
dir_data_path <- "data/GSE150728_RAW"


# list files in the folder
mat.list = paste(dir_data_path, list.files(pattern = "*.matrices.rds", path = dir_data_path),
                 sep = "/")

mat.files = lapply(mat.list, readRDS)     


# load data into R and generate sparse matrices
names(mat.files) <- sapply(strsplit(sub("genes_matrix", "", 
                                        mat.list), "/"), function(x) x[2])


# assign a name to each matrix
names(mat.files) <- sapply(strsplit(sub("_cell.counts.matrices.rds", "", mat.list), "/"), function(x) tail(x, 1))



# -NOTE: The mat.files object contains three count matrices generated by the dropEsst 
#pipeline tool: exon, intron, and exon/intron spanning reads.
# Since exonic reads are the reads used in scRNA-seq analysis for quantifying gene expression, 
# we select only the exonic count for each sample.

# let's have a look at the counts of the first 20 genes and cells for one sample:
mat.files$GSM4557329_556$exon[1:20, 1:20]



# initialize a seurat object for each sample by filtering out genes that are expressed in fewer than 10 cells
# (mild filtering)
# list of matrices
# keep only the exon
seurat.list <- lapply(mat.files, function(x) {
  CreateSeuratObject(
    counts = x$exon,
    names.field = 1, 
    names.delim = "\\.",
    project = "CovidProject",
    min.cells = 10, 
    min.features = 0
  )
})
print(seurat.list)


# seural list -> multi-levels layers (addition to origin count matrix,  
# also store data generated during the analysis, normalized counts, clustering results)

# let's look at one suerat object
seurat.list$GSM4557329_556

# show nb of cells and genes 
ncol(seurat.list$GSM4557329_556) # nb cells
nrow(seurat.list$GSM4557329_556) # nb genes


# get cell/ barcode names
colnames(seurat.list$GSM4557329_556)
Cells(seurat.list$GSM4557329_556) # names of the cells

# get gene/ featurs names
rownames(seurat.list$GSM4557329_556)
Features(seurat.list$GSM4557329_556)


# get count matrix 
seurat.list$GSM4557329_556@assays$RNA$counts
seurat.list$GSM4557329_556[['RNA']]$counts


# seurat package offers practical functions to quickly access information 
# to get the count matrix
GetAssayData(object = seurat.list$GSM4557329_556, layer = "counts")




############################## Assign Metadata ######################


# vizualise metadata 

View(seurat.list$GSM4557329_556@meta.data)
#ncount_RNA 
#nFeature_RNA (genes)



# add new metadata 
# sample name 
# condtition - label indicating sample condition/ group
sample_names <- names(seurat.list)
for (i in seq_along(seurat.list)) {
    seurat.list[[i]]@meta.data$sample <- unlist(strsplit(sample_names[i], split = "_"))[1]
    seurat.list[[i]]@meta.data$condition <- ifelse(grepl("HIP", sample_names[i]), "hc", "covid") 
}
print(seurat.list)
# vizualise metadata again
head(seurat.list$GSM4557329_556@meta.data)



################################# Data QC ################################

# Vizualize QC per cell 

# one sample 

# plot the number of read/UMI counts and detected genes per cell to evaluate
# their distribution and identify cells and genes that cause variation in the dataset
# due to technical reasons (e.g sampling or dissociation)

# cells with low counts or detected genes might be uninformative 
# while high counts or detected genes could indicate doublets


# VlnPlot function draws a violin plot from a Seurat object
# see the outliers
VlnPlot(seurat.list$GSM4557329_556, features = c("nCount_RNA", "nFeature_RNA"), group.by = "sample")
ggsave("romane/images/counts_features_by_cell.png", width =  3500, height = 1500, dpi = 300, units = "px")



# plot correlatation bw number of reads counts and detected genes per cell to identify an upper threshold
# high quality cells show a higher nb of reads and higher number of detected genes (good correlation)


# featurescatter draws a scatter plot from a seurat object
FeatureScatter(seurat.list$GSM4557329_556,
               "nCount_RNA", "nFeature_RNA",
               group.by= "sample")
ggsave("romane/images/counts_vs_features.png", width = 1500, height = 1000, 
       dpi = 300, units = "px")




############################## All samples ######################

# plot the nb of read/UMI counts per cell for each sample 
plots.list <- lapply(seurat.list, function(x) {
  VlnPlot(x, features = c("nCount_RNA"),
          group.by = "sample")})
wrap_plots(plots.list, ncol = 3)
ggsave("romane/images/counts_vs_features_by_sample.png", width = 6000, height = 3000, 
       dpi = 300, units = "px")

############################## Filter UMIs and detected genes ######################

# remove cells with extremely low and high UMI counts as they are considered as low-quality cells.
# note: 500 and 15 000 can be good a threshold on average, but filtering 
# should be done for each sample inidividually 

seurat.list.filtered <- lapply(seurat.list, function (x){
  subset(x, subset = nCount_RNA > 500 & nCount_RNA < 15000) })


# remove cells with very low and high nb of detected genes 
# note: 200 and 4000 can be good thresholds, but filtering should be done for each sample individually
seurat.list.filtered <- lapply(seurat.list.filtered, function (x) {
  subset(x, subset = nFeature_RNA > 200 & nFeature_RNA < 4000) })


# show number of cells before and after filtering
sapply(seurat.list, ncol)
sapply(seurat.list.filtered, ncol)



# vizualise QC per cell 
#---------------------------- One sample -----------------------------

# plot the number of read counts and detected genes per cell
VlnPlot(seurat.list.filtered$GSM4557329_556,
        features = c("nCount_RNA", "nFeature_RNA"),
        group.by = "sample")
ggsave("romane/images/filtered_counts_features_by_cell.png", width = 3500, height = 1500,
       dpi = 300, units = "px")


# plot the correlation bw nb of read counts and detected genes per cell
FeatureScatter(seurat.list.filtered$GSM4557329_556,
               "nCount_RNA", "nFeature_RNA",
               group.by = "sample")

ggsave("romane/images/filtered_counts_vs_features.png", width = 1500, height = 1000,
       dpi = 300, units = "px")

View(seurat.list.filtered$GSM4557329_556@meta.data)



# results: correlation has slightly improved


#---------------------------- All sample -----------------------------
# plot the nb of read counts per cell for each sample
plots.list <- lapply(seurat.list.filtered, function(x){
  VlnPlot(x, features = c("nCount_RNA"), group.by = "sample")})

wrap_plots(plots.list, ncol = 3)
ggsave("romane/images/filtered_count_by_cell_by_sample.png",
       width = 6000, height = 3000,
       dpi = 300, units = "px")

# plot the nb of detected genes per cell for each sample
plots.list <- lapply(seurat.list.filtered, function(x){
  VlnPlot(x, features = c("nFeature_RNA"), group.by = "sample")})

wrap_plots(plots.list, ncol = 3)
ggsave("romane/images/filtered_features_by_cell_by_sample.png",
       width = 6000, height = 3000,
       dpi = 300, units = "px")




# plot correlation bw number of read counts and detected genes per cell for each sample
plots.list <- lapply(seurat.list.filtered, function(x) {
  FeatureScatter(x, "nCount_RNA","nFeature_RNA",
                 group.by = "sample")})
wrap_plots(plots.list, ncol = 3)
ggsave("romane/images/filtered_counts_vs_features_by_sample.png",
       width = 6000, height = 3000,
       dpi = 300, units = "px")



############################## # Identify the putative doublets (or multiplets)######################

# additional filtering can be applied to improve doublets detection accuracy 
# using DoubletFinder package.
# Note: DoubletFinder package requires fully processed Seurat object (including NormalizeData(), FindVariableFeatures(), 
# scaleData(), and RunPCA(), in order
# to assign singlet or doublet labels to each cell 


############################## Calculate the % of mitochondrial and ribosomal genes #####################

 
# we will filter out cells containing high percentage of reads from mitochondrial 
# and ribosomal genes as they are considered low-quality

# MT: mitochondrial RNA
# Note: high relative abundance of mitochondrial genes can indicate damaged cells
lapply(seurat.list.filtered, function(x) {grep("^MT-", rownames(x), value = TRUE)})
seurat.list.filtered <- lapply(seurat.list.filtered, function(x){
  PercentageFeatureSet(x, pattern = "^MT-", col.name = "percent.mito")})

#View(seurat.list.filtered$GSM4557329_556@meta.data)




# RPS: ribosomal protein small subunit 
# RPL: ribosomal protein large subunit 
# note: it represents mRNA codinf for ribosomal proteins 
lapply(seurat.list.filtered, function(x) {grep("^RP[LS]", rownames(x), value = TRUE)})
seurat.list.filtered <- lapply(seurat.list.filtered, function(x){
  PercentageFeatureSet(x, pattern = "^RP[LS]", col.name = "percent.ribo")})


# vizualise metadata
View(seurat.list.filtered$GSM4557329_556@meta.data)


# Vizualise QC per cell 

#---------------------------- One sample -----------------------------

# plot percentage of mitochondrial RNA per cell 
VlnPlot(seurat.list.filtered$GSM4557329_556,
        features = c("percent.mito", "percent.ribo"),
        group.by = "sample", ncol = 2)

ggsave("romane/images/mito_ribo_by_cell.png", width = 3000, height = 2000,
       dpi = 300, units = "px")



#---------------------------- All sample -----------------------------

# plot percentage of mitochondrial RNA per cell for each sample
plots.list <- lapply(seurat.list.filtered, function(x){
  VlnPlot(x, features = c("percent.mito"), group.by = "sample")})
wrap_plots(plots.list, ncol = 3)
ggsave("romane/images/mito_by_cell_by_sample.png",
       width = 6000, height = 3000, 
       dpi = 300, units = "px")


# plot percentage of ribosomal RNA per cell for each sample
plots.list <- lapply(seurat.list.filtered, function(x){
  VlnPlot(x, features = c("percent.ribo"), group.by = "sample")})
wrap_plots(plots.list, ncol = 3)
ggsave("romane/images/ribo_by_cell_by_sample.png",
       width = 6000, height = 3000, 
       dpi = 300, units = "px")



################# Filtering mitochondrial and ribosomal genes #####################


# apply filtering for mitochondrial RNA
seurat.list.filtered <- lapply(seurat.list.filtered, function (x) {
  subset(x, subset = percent.mito < 20) })

seurat.list.filtered <- lapply(seurat.list.filtered, function (x) {
  subset(x, subset = percent.ribo < 20) })

View(seurat.list.filtered$GSM4557329_556@meta.data)


# show number of cells
sapply(seurat.list.filtered, ncol)


# show number of genes
sapply(seurat.list.filtered, nrow)



# Vizualise QC per cell 


#---------------------------- One sample -----------------------------

# plot percentage of mitochondrial RNA per cell

VlnPlot(seurat.list.filtered$GSM4557329_556,
        features = c("percent.mito","percent.ribo"),
        group.by = "sample", ncol = 2)

ggsave("romane/images/filtered_mito_ribo_by_cell.png", width = 3000, height = 2000,
       dpi = 300, units = "px")




#---------------------------- All sample -----------------------------

# plot percentage of mitochondrial RNA per cell for each sample
plots.list <- lapply(seurat.list.filtered, function(x){
  VlnPlot(x, features = c("percent.mito"), group.by = "sample")})
wrap_plots(plots.list, ncol = 3)
ggsave("romane/images/filtered_mito_by_cell_by_sample.png",
       width = 6000, height = 3000, 
       dpi = 300, units = "px")


# plot percentage of ribosomal RNA per cell for each sample
plots.list <- lapply(seurat.list.filtered, function(x){
  VlnPlot(x, features = c("percent.ribo"), group.by = "sample")})
wrap_plots(plots.list, ncol = 3)
ggsave("romane/images/filtered_ribo_by_cell_by_sample.png",
       width = 6000, height = 3000, 
       dpi = 300, units = "px")


# save results
saveRDS(seurat.list.filtered, "./romane/filtered_covid_obj.rds")





# Normalization vs Batch effect correlation
# Normalization: adjusts for cell-speciric technical artifacts and biais 
# to make gene expression comparable across cells

# Batche effect: can affect gene expression with systematic errors and variations due to diff 
# in exerimental settings, tissue colleciton, samples processing times
# in scRNA-seq: control technical and cell to cell variabiliy


# selet subset genes highly differentiable
# in seurat: FindVariableFeatures()



#################### Merging (W/o integration) and normalization ####################
# we first analyze data without integration and batch effect correction
# by following  the standard seurat workflow 
# to simpligy the analysis, we will merge the Seurat Objects in a single object.
# Note: with 'merge' count matrices are kept separated


# load saved object
seurat.list.filtered <- readRDS("./romane/filtered_covid_obj.rds")



# data filtering
# merge Seurat objects
# new extension to the identifier (representing the sample)
merged.seurat.obj <- merge(
  x = seurat.list.filtered[[1]],
  y = seurat.list.filtered[2:length(seurat.list.filtered)],
  add.cell.ids = str_split_fixed(names(seurat.list.filtered), "_", 2)[,2])


# vizualise metadata
View(merged.seurat.obj@meta.data)

# show nb of cells/ genes
# ??? not the same nb ??????
ncol(merged.seurat.obj)
nrow(merged.seurat.obj)



# data normalization on each layer
# ensures that expression levels are comparable across cells and variable features seleciton is more accurate


# show raw counts
raw_counts <- merged.seurat.obj@assays$RNA$counts.1
head(raw_counts)

raw_hist <- hist(as.vector(raw_counts), breaks = 50, plot = FALSE)

raw_hist$counts <- log1p(raw_hist$counts)

png("romane/images/raw_counts_hist.png",
    width = 1500, height = 1500, 
    res = 300, units = "px")

plot(raw_hist, col = "#bc91a5",
     main = NULL, 
     xlab = "Raw counts",
     ylab = "Log-transformed frequency")

dev.off()


# seurat normalizes gene exprsesion by dividing each gene count by the total UMI counts per cell,
# multiplying by a scale factor and log-transforming the result (global-scaling)
# raw counts stored in the layer named 'counts' and normalized in the layer 'data'

merged.seurat.obj <- NormalizeData(merged.seurat.obj,
                                   normalization.method = "LogNormalize",
                                   scale.factor = 10000)


# show log-mormalized counts
noramalized_counts <- merged.seurat.obj@assays$RNA$data.1
head(noramalized_counts)


# generate histogram for the normalized data
normalized_hist <- hist(as.vector(noramalized_counts), breaks = 50, plot = FALSE)

#log-transform counts histogram with log-transformed frequency
normalized_hist$counts <- log1p(normalized_hist$counts)

png("romane/images/normalized_counts_hist.png",
    width = 1500, height = 1500,
    res = 300, units = "px")

# histogram of our normalized counts
plot(normalized_hist, col = "#bc91a5",
     main = NULL,
     xlab = "Log-normalized counts",
     ylab = "Log-transformed frequency")

dev.off()

# changes the normalization method
cpm.seurat.obj <- NormalizeData(merged.seurat.obj,
                                normalization.method = "RC",
                                scale.factor = 1e6)

# show CPM
cpm_counts <- cpm.seurat.obj@assays$RNA$data.1
head(cpm_counts)


# generate histogram for CPM 
cpm_hist <- hist(as.vector(cpm_counts), breaks = 50, plot = FALSE)

# log-transform the frequency (y-axis)
cpm_hist$counts <- log1p(cpm_hist$counts)

# plot CPM histogram with log-transformed frequency
png("romane/images/cpm_counts_hist.png",
    width = 1500, height = 1500,
    res = 300, units = "px")

plot(cpm_hist, col = "#bc91a5",
     main = NULL,
     xlab = " Counts per million (CPM)",
     ylab = "log-transformed frequency")

dev.off()




#################### Identify variable genes ####################


# we calculate the standardized variance of gene expression across cells 
# for each gene. This is essential for identifying genes that vary the most across cells
# which are often the most biologically relevant for downstream analyses
# like PCA or clustering

# Note: when identifying variable features, seurat first calculates them for 
# each individual layer/ sample, then identifies the common ones across layers
# (consistently variable across all samples), and finally, it extends the list 
# of variable features until the desired number is reached (2000 by default)


merged.seurat.obj <- FindVariableFeatures(merged.seurat.obj,
                                          selection.method = "vst",
                                          nFeatures = 2000)



View(merged.seurat.obj@assays$RNA@meta.data)
# results - TRUE/ FALSE if gene is variable or not
# ranking of the most variable gene 
# at the end: var.features (names of genes)


# Plot the top 10 variable genes/ features
top_10_genes <- head(VariableFeatures(merged.seurat.obj), 10)
top_10_genes_plot <- VariableFeaturePlot((merged.seurat.obj))


# add the name of the genes on the histogram
LabelPoints(plot = top_10_genes_plot, points = top_10_genes,
            repel = TRUE, xnudge = 0, ynudge = 0)

ggsave("romane/images/top_10_genes.png",
       width = 2000, height = 2000,
       dpi = 300, units = "px")


# Results
# most genes IGHA1 -> monoglubin genes -> produce antibodies involved in immune response 

# later- identify in which cells these genes are expressed 


# Save Results (for subsequent analysis)
saveRDS(merged.seurat.obj, "./romane/merged_covid_obj.rds")
















